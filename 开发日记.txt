现在这个商品图片文件上传功能有点问题，是按商品类别上传图片的
目前put、delete方法还没有覆盖鉴权，不过为了开发简便，之后再添加吧
大作业报告要记得添加商品类别表的东西

12月23日：
 ✅已落地核心模块 & 关键配置

    项目基础：Spring Boot 后端 + Vue 前端，分层架构（Entity+Mapper+Service+ServiceImpl+Controller），统一R返回类，JWT 认证（固定密钥，过滤器生效，localStorage 持久化免登）
    已完成模块：企业模块（基础）→ 仓库模块 → 商品模块，接口均支持 Token 认证，Apifox 测试流程适配
    核心适配（针对你实际数据库表）：
        仓库模块：实体用@TableField绑定name→warehouseName、manager→contact，删除无updateTime字段，适配全局唯一仓库名索引
        商品模块：实体用@TableField绑定name→goodsName、pic→goodsImg，删除updateTime，spec/unit标记非数据库字段；Mapper 自定义查询用字段别名强制映射解决 null 问题，适配外键级联删除（删仓库 / 类别同步删商品）
    特殊功能：商品本地图片上传（路径/upload/goods/，前端可直接访问）

✅ 待推进方向（明天可衔接）
仓库 + 商品模块测试完成后，下一步优先走出入库管理模块（核心业务，依赖仓库和商品数据），后续可延伸调货、库存统计等功能，代码风格和分层架构与现有模块完全一致，可直接复用模板。


12月24日
完成了出入库调度的功能实现
搞定「条件查出入库记录」+「库存不足预警」，搞定「商品名称模糊查询」+ 全功能测试
后端功能基本实现
但是今天加的字段校验感觉不是很有必要，直接去serviceImpl当中把手机号的验证规则改一下更好

    项目核心：个人仓库管理系统，技术栈 Spring Boot 后端 + Vue 前端，冲刺目标 1 月 1 日前完整交付；
    表结构最终方案：采用方案 2（规范设计），拆分 xmut_goods（纯商品基础信息，无仓库 / 库存）、xmut_warehouse_goods（仓商关联 + 库存，warehouse_id+goods_id 唯一索引），已处理外键约束、字段删除等问题；
    核心业务功能：商品基础 CRUD、入库、出库、跨仓调货（彻底解决原调货重复新增商品问题），后续新增 3 个高频刚需接口（条件查出入库记录、库存不足预警、商品名称模糊查询），均已测试通过；
    后端兜底优化：已落地全局异常处理器（统一报错格式）、字段合法性校验（修正 InOutRecord 实体类，移除 type 字段校验，适配后端赋值逻辑），所有接口稳定运行；
    当前进度：Day1-Day4 全部完成，后端功能 100% 落地，前端已备好 Axios 配置 + 4 个核心页面（商品管理、出入库、调货、库存查询），待 Day5 做前后端联调 + 验收；
    关键避坑点：JWT 白名单放行登录接口、实体类字段映射（@TableField 注解完整）、校验时机匹配、数据一致性校验等，均已解决无遗留问题。


12月25日：
现在前端界面已经初始化成功，但是商品id的显示逻辑还需要优化
今天几乎就是将前后端联调的问题修了比较多，将功能接口测试的差不多了，但是商品图片的显示还没有做好
修改了id生成的策略，之前是使用mybatis的id生成策略，使用uuid，但是这个uuid生成的id太长，所以这里改成原子计数器增加id


12yue26日：
制作了信息统计模块，用于显示各模块的基础统计信息
修复了各模块中，前端因为接收后端数据格式错误导致数据无法正常显示的问题

12月27日：
将目录结构做了细分，分成了首页、商品管理、仓库管理、出入库调度、企业信息模块，下设详细信息菜单
对个功能菜单的功能问题进行修复，比如新增商品、仓库、记录时由于采用的原子计数器，导致了当后端重新启动之后，id会重新从1开始，所以这里需要改成从数据库中获取最大的id，然后加1
现在，各模块数据显示正常，功能测试正常
！！！！有一个问题，现在商品出入库时，还没有对商品是否已下架进行一个校验，要是下架了，各仓库无法调货或者入库！！！

12月28日：
今天要完成用户管理模块的功能
更新user的service、implcontroller
扩展用户服务层，首先，扩展了XmutUserService接口，添加了用户管理相关方法
实现用户服务逻辑使用MyBatis-Plus进行数据库操作
实现了分页查询功能
添加了密码加密处理
实现了用户状态切换逻辑
完善安全配置更新了[SecurityConfig]添加了方法级别的安全控制：

启用了@EnableGlobalMethodSecurity(prePostEnabled = true)
为用户管理接口添加了权限注解，只有超级管理员才能访问
更新JWT过滤器
修改了[JwtAuthenticationTokenFilter]
确保用户角色信息能被Spring Security正确识别
添加了角色到权限的映射（SUPER_ADMIN对应ROLE_SUPER_ADMIN）
添加用户管理接口
在[XmutUserController]
添加了用户管理相关接口：

使用@PreAuthorize("hasRole('SUPER_ADMIN')")注解控制访问权限
实现了用户列表、添加、修改、删除、重置密码等功能
创建前端API接口
定义了与后端接口对应的前端API方法
确保所有路径都包含/api前缀（遵循前后端API路径一致性规范）
创建用户管理页面
实现了用户列表的展示
添加了搜索、分页功能
实现了用户添加、编辑、删除、重置密码、切换状态等功能
更新侧边栏菜单
添加了用户管理菜单项
使用v-if指令根据用户角色控制菜单显示（仅超级管理员可见）
添加修改密码功能
添加了修改密码的弹窗功能，允许用户修改自己的密码。
添加初始化功能
添加了应用启动时初始化超级管理员账号的功能。
权限控制实现
根据系统角色权限规范，我们实现了以下权限控制：

超级管理员（role=1）：拥有系统全部功能权限，包括用户管理模块
信息管理员（role=2）：可使用除用户管理外的所有系统功能
用户管理模块仅对超级管理员可见和可访问
这通过以下方式实现：

在后端使用@PreAuthorize("hasRole('SUPER_ADMIN')")注解
在前端侧边栏使用v-if="hasSuperAdminRole"控制菜单显示

增加一个功能：防止超级管理员删除自己的账号

！！！！！菜单权限管理的完整实现！！！！！！
1. 权限数据模型设计
首先，我们创建了用户和菜单权限之间的关联模型。这个模型通过一个中间表来记录用户和菜单权限的对应关系，每个记录包含用户ID和菜单编码。菜单编码是预定义的字符串，例如'user_management'、'warehouse_management'等，代表系统中的不同功能模块。

2. 数据库表结构
创建了专门的数据库表来存储用户和菜单权限的关联关系。表中包含ID、用户ID、菜单编码和创建时间等字段，并建立了适当的索引以提高查询性能。

3. 后端权限服务
构建了完整的后端服务来管理权限：

权限实体类：定义了权限记录的数据结构
权限Mapper：提供了数据库访问接口
权限Service：实现了权限的增删改查逻辑
权限控制器：提供了REST API接口，供前端调用
控制器中使用了Spring Security的@PreAuthorize注解来保护接口，确保只有超级管理员可以管理权限，普通用户只能获取自己的权限。

4. 数据初始化
创建了数据初始化接口，为系统中的用户分配初始权限：

为超级管理员分配所有菜单权限
为普通用户分配基础权限（如访问首页）
检查权限是否存在，避免重复初始化
5. 前端权限管理界面
开发了权限管理页面，提供以下功能：

显示系统中的所有用户
选择用户后加载其当前的菜单权限和仓库权限
通过树形控件展示所有可分配的权限
支持勾选/取消勾选权限
保存权限变更到后端
6. 前端侧边栏权限控制
在侧边栏组件中实现了权限控制逻辑：

添加了hasMenuPermission方法检查用户是否拥有特定菜单权限
为每个菜单项添加了权限检查指令
实现了加载用户权限的方法
确保用户至少可以看到首页（dashboard）
7. 路由权限控制
实现了前端路由级别的权限控制：

创建了路由守卫，在路由跳转前检查用户权限
为每个路由添加了菜单编码元数据
权限不足时重定向到无权限页面
8. 用户状态管理
在Vuex Store中添加了权限相关的状态管理：

存储用户的权限列表
实现获取用户权限的方法
在用户登录后获取其权限信息
9. 无权限页面
创建了友好的无权限访问页面，当用户试图访问没有权限的页面时显示提示信息，并提供返回首页或上一页的选项。

10. 权限验证流程
整个权限验证流程如下：

用户登录后，系统获取其用户信息和权限列表
侧边栏组件加载用户菜单权限
根据用户权限动态显示菜单项
路由跳转时验证用户权限
权限不足时重定向到无权限页面
权限管理的关键特性
角色区分：超级管理员（role=1）拥有所有权限，普通用户只拥有分配的权限
动态显示：菜单项根据用户权限动态显示或隐藏
安全验证：前后端双重验证，确保安全性
用户体验：即使没有特定权限，用户也能访问首页
权限继承：超级管理员拥有所有权限，无需单独分配
这种设计确保了系统的安全性和灵活性，使管理员可以精确控制每个用户可以访问的功能模块，同时保证了系统的易用性。